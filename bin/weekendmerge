sub merge_weekends {@scheds = sort grep (/(Sun|Satur)day/ , (keys %fullsched) ) ;    return unless @scheds;DAY: foreach $day (0,2) {   foreach ( qw(TP NOTES) ) {      next DAY if scalar @{$fullsched{$sched[$day]}{$_}}          != scalar @{$fullsched{$sched[$day+1]}{$_}}         }      # if the number of timepoints or rows are different, skip it      foreach ( qw(TIMEPOINTS NOTES LINES TP)) {         next DAY          if join ("" , @{$fullsched{$sched[$day]}{$_}})             ne join ("" , @{$fullsched{$sched[$day+1]}{$_}}) ;   }      # if the text of any of the data is different skip it      for ($_ =0; $i < scalar @{$fullsched{$sched[$day]}{"TIMES"}[0]}  ;  $i++) {         next DAY         if join ("" , @{$fullsched{$sched[$day]}{"TIMES"}[$_]})            ne join ("" , @{$fullsched{$sched[$day+1]}{"TIMES"}[$_]})   }   # if any of the times are different, skip it.      # At this point, we know they're identical. References make it pretty easy.      $newschedname = $sched[$day];      $newschedname =~ s/(Sun|Satur)day/Weekend/;      $fullsched{$newschedname} = $fullsched{$sched[$day]};      # remember, that's a reference. Same reference, same thing.      delete $fullsched{$sched[$day]};   delete $fullsched{$sched[$day+1]}      # so now, the original two days are gone, but the first day is still stored   # in $fullsched{$newschedname}  (which is going to be "[something]bound Weekend Schedule")   }}