#!/usr/bin/perl

# avl2points - see POD documentation below

#00000000111111111122222222223333333333444444444455555555556666666666777777777
#23456789012345678901234567890123456789012345678901234567890123456789012345678

use warnings;
use strict;

use sort ('stable');

# add the current program directory to list of files to include
use FindBin('$Bin');
use lib (
    $Bin, "$Bin/../bin",
);

use Carp;
use POSIX ('ceil');

#use Fatal qw(open close);
use Storable();

use Actium::Timenum (qw(time_to_timenum timenum_to_12h timenum_to_12h_ap_only));
use Actium(
    qw[say sayt jn jt byroutes jtn initialize key avldata ensuredir option]);
use Actium::Constants;
use Actium::Union('ordered_union');
use List::MoreUtils (qw<any all>);

# don't buffer terminal output
$| = 1;

my $helptext = <<'EOF';
avl2points reads the data written by readavl and turns it into 
a list of times that buses pass each stop.
It is saved in the directory "kpoints" in the directory for that signup.
EOF

my $intro = 'avl2points -- makes list of times that buses pass each stop';

#my %daysort = (
#    DA => 0,
#    WD => 1,
#    WE => 2,
#    SA => 3,
#    SU => 4,
#    MZ => 100,
#    TT => 120,
#    TF => 121
#);

Actium::initialize( $helptext, $intro );

# retrieve data

my ( %stopinfo, %note_of );

{    # more scoping

    my $somedata_r;

    {    # scoping

        my $avldata_r = avldata();

        foreach (qw<PAT TRP>) {
            $somedata_r->{$_} = $avldata_r->{$_};
        }

    }

    %stopinfo = makestoptimes($somedata_r);
 
}

print "Combining combo routes...\n";

my %combo_of = (qw<
    L   LC      LA  LC
    NX1 NC      NX2 NC     NX3 NC   >);
my %is_combo;
$is_combo{$_}++ foreach values %combo_of;

foreach my $stop ( keys %stopinfo ) {

    foreach my $combolg ( keys %{ $stopinfo{$stop} } ) {

        if (is_combo{$combolg} ) {
           foreach my $singlelg ( keys %{ $stopinfo{$stop} } ) {
              if ($combo_of{$singlelg} eq $combolg) {

                  foreach my $dir_code ( keys %{ $stopinfo{$stop}{$combolg} } ) {
                     foreach my $days ( keys %{ $stopinfo{$stop}{$combolg}{$dir_code} } ) {
                        foreach my $time_r ( @{ $stopinfo{$stop}{$combolg}{$dir_code}{$days} } ) {
                             $time_r->{LINE} = $singlelg;
                             push @{ $stopinfo{$stop}{$singlelg}{$dir_code}{$days} } , $time_r ;
                        }
                             
                     }

                  }

              }
           }
           delete $stopinfo{$stop}{$combolg};
        }

    }

}

# now each of $stopinfo{$stop}{$linegroup}{$dir_code}{$days}[0..n]
# is a hashref, with the keys TIME , DESTINATION, and LINE

print "Sorting times and merging days...\n";

my @nolocals = qw<FS L NX NX1 NX2 NX3 U W>;
my %is_a_nolocal_route;
$is_a_nolocal_route{$_} = 1 foreach @nolocals;

my @routenotes = qw<1R 72R>;
my %is_a_routenote;
$is_a_routenote{$_} = 1 foreach @routenotes;

foreach my $stop ( keys %stopinfo ) {

    foreach my $linegroup ( keys %{ $stopinfo{$stop} } ) {

        my (%has_last_stop , %has_non_last_stop);

        # processing times within each day
        foreach my $dir_code ( keys %{ $stopinfo{$stop}{$linegroup} } ) {

            my %concatenated;

            foreach my $days ( keys %{ $stopinfo{$stop}{$linegroup}{$dir_code} } ) {

                my @times_hr
                  = @{ $stopinfo{$stop}{$linegroup}{$dir_code}{$days} };

                # sort @times_hr first by time, then by line, then by dest

                @times_hr = sort {
                    ( time_to_timenum( $a->{TIME} )
                      <=> time_to_timenum( $b->{TIME} ) )
                      or $a->{LINE} cmp $b->{LINE}
                      or $a->{DESTINATION} cmp $b->{DESTINATION}
                } @times_hr;

                $stopinfo{$stop}{$linegroup}{$dir_code}{$days} = \@times_hr;

                my @each_time_concat
                  = map { join( ':', $_->{TIME}, $_->{LINE}, $_->{DESTINATION} ) }
                  @times_hr;

                $concatenated{$days}
                  = join( ':', @each_time_concat );

            } ## <perltidy> end foreach my $days ( keys %{ ...})

            # merge days (columns with times)

            if (    exists( $concatenated{'6'} )
                and exists( $concatenated{'7'} )
                and $concatenated{'6'} eq
                $concatenated{'7'} )
            {

                $concatenated{'67'}
                  = $concatenated{'6'};
                $stopinfo{$stop}{$linegroup}{$dir_code}{'67'}
                  = $stopinfo{$stop}{$linegroup}{$dir_code}{'6'};

                delete $concatenated{'6'};
                delete $concatenated{'7'};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'6'};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'7'};

            }

            if (    exists( $concatenated{'67'} )
                and exists( $concatenated{'12345'} )
                and $concatenated{'67'} eq
                $concatenated{'12345'} )
            {

                #$concatenated{$dir_code}{'1234567'}
                #  = $concatenated{$dir_code}{'12345'};
                $stopinfo{$stop}{$linegroup}{$dir_code}{'1234567'}
                  = $stopinfo{$stop}{$linegroup}{$dir_code}{'12345'};

                #delete $concatenated{$dir_code}{'67'};
                #delete $concatenated{$dir_code}{'12345'};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'67'};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'12345'};

            }

            # LAST STOP PROCESSING

            DAYS_NOTESLOOP:
            foreach my $days ( keys %{ $stopinfo{$stop}{$linegroup}{$dir_code} } ) {
                 # loop - deal with final stops. Add notes

                 my $times_r = $stopinfo{$stop}{$linegroup}{$dir_code}{$days};

                 # LASTSTOP

                 if ( all { $_->{PLACE} eq $_->{DESTINATION} } @{$times_r} ) {
                    $has_last_stop{$linegroup} = 1;
                    $note_of{"$stop:$linegroup:$dir_code:$days"}{NOTE} = "LASTSTOP"
                 } 
                 else {
                 
                    $has_non_last_stop{$linegroup} = 1;
                    foreach my $i ( reverse 0 .. $#{$times_r} ) {
                        if ($times_r->[$i]->{PLACE} eq $times_r->[$i]->{DESTINATION}) {
                           splice (@{$times_r} , $i, 1);
                        }
                    }
                 }
 
                 # DROPOFF

                 if ($is_a_nolocal_route{$linegroup} and $dir_code eq '2') {
                     #eastbound
                     $note_of{"$stop:$linegroup:$dir_code:$days"}{NOTE} = "DROPOFF";
                 }

                 # TODO - figure out how to do line U

                 if ($is_a_routenote{$linegroup} ) {
                     $note_of{"$stop:$linegroup:$dir_code:$days"}{NOTE} = $linegroup;
                 }

                 if ($note_of{"$stop:$linegroup:$dir_code:$days"}) {
                    
                   my (%lines, %destinations);
                   foreach my $time_r ( @{ $stopinfo{$stop}{$linegroup}{$dir_code}{$days} } ) {
                      $lines{$time_r->{LINE}}++;
                      $destinations{$time_r->{DESTINATION}}++;
                   }

                   my @lines = sort byroutes keys %lines;
                   my @destinations = 
                       sort { $destinations{$b} <=> $destinations{$a} } keys %destinations;

                   $note_of{"$stop:$linegroup:$dir_code:$days"}{INFO}
                        = join (":" , @lines) .  "\t" . 
                          join (":" , @destinations);

                   $note_of{"$stop:$linegroup:$dir_code:$days"}{COMP}
                        = $note_of{"$stop:$linegroup:$dir_code:$days"}{NOTE} . 
                          join (":" , @lines) .  "\t$destinations[0]";

                 }

            }

            # merge notes

            if (
                $note_of{"$stop:$linegroup:$dir_code:6"} and
                $note_of{"$stop:$linegroup:$dir_code:7"} and
                $note_of{"$stop:$linegroup:$dir_code:6"}{COMP} eq  
                $note_of{"$stop:$linegroup:$dir_code:7"}{COMP} ) {

                $stopinfo{$stop}{$linegroup}{$dir_code}{'67'}
                  = $stopinfo{$stop}{$linegroup}{$dir_code}{'6'};
                 $note_of{"$stop:$linegroup:$dir_code:67"} =
                    $note_of{"$stop:$linegroup:$dir_code:6"};

                delete $note_of{"$stop:$linegroup:$dir_code:6"};
                delete $note_of{"$stop:$linegroup:$dir_code:7"};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'6'};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'7'};

            }


            if ($note_of{"$stop:$linegroup:$dir_code:67"} and
                $note_of{"$stop:$linegroup:$dir_code:12345"} and
                $note_of{"$stop:$linegroup:$dir_code:67"}{COMP} eq  
                $note_of{"$stop:$linegroup:$dir_code:12345"}{COMP} ) {

                $stopinfo{$stop}{$linegroup}{$dir_code}{'1234567'}
                  = $stopinfo{$stop}{$linegroup}{$dir_code}{'12345'};
                 $note_of{"$stop:$linegroup:$dir_code:1234567"} =
                    $note_of{"$stop:$linegroup:$dir_code:12345"};

                delete $note_of{"$stop:$linegroup:$dir_code:12345"};
                delete $note_of{"$stop:$linegroup:$dir_code:67"};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'12345'};
                delete $stopinfo{$stop}{$linegroup}{$dir_code}{'67'};

            }

            # above handles all of 1R except the parts heading northbound
            # to downtown Oakland (which has mixed destinations)

            if ($note_of{"$stop:$linegroup:$dir_code:67"}    and
                $note_of{"$stop:$linegroup:$dir_code:12345"} and
                $note_of{"$stop:$linegroup:$dir_code:67"}{NOTE} eq '1R' and
                $note_of{"$stop:$linegroup:$dir_code:12345"}{NOTE} eq '1R' ) {
                # we know they are different destinations because otherwise they would
                # already be merged

                $stopinfo{$stop}{$linegroup}{$dir_code}{'1234567'}
                    = $stopinfo{$stop}{$linegroup}{$dir_code}{'12345'};
                $note_of{"$stop:$linegroup:$dir_code:1234567"} =  
                   $note_of{"$stop:$linegroup:$dir_code:12345"};
                    
                $note_of{"$stop:$linegroup:$dir_code:1234567"}{NOTE} = '1R-MIXED';

            }

        } ## <perltidy> end foreach my $dir_code ( keys...)

    if ( $has_non_last_stop{$linegroup} and $has_last_stop{$linegroup} ) {
       # if there are both last-stop and non-last-stop columns for this linegroup,
       # delete the last-stop columns

       foreach my $dir_code ( keys %{ $stopinfo{$stop}{$linegroup} } ) {

          foreach my $days ( keys %{ $stopinfo{$stop}{$linegroup}{$dir_code} } ) {

              if ( $note_of{"$stop:$linegroup:$dir_code:$days"} and
                  $note_of{"$stop:$linegroup:$dir_code:$days"}{NOTE} eq "LASTSTOP" ) {
                  delete $stopinfo{$stop}{$linegroup}{$dir_code}{$days};
                  delete $note_of{"$stop:$linegroup:$dir_code:$days"} ;
              }

          }

       }

    }


    } ## <perltidy> end foreach my $linegroup ( keys...)


} ## <perltidy> end foreach my $stop ( keys %stopinfo)

print "Reassembled. Now outputting...\n";

ensuredir('kpoints');

my $count = 0;

foreach my $stop ( keys %stopinfo ) {

    $count++;
    print '.' unless $count % 100;

    my $citycode = substr( $stop, 0, 2 );

    ensuredir("kpoints/$citycode");

    open my $out, '>', "kpoints/$citycode/$stop.txt" or die $!;

    foreach my $linegroup ( sort byroutes keys %{ $stopinfo{$stop} } ) {

        foreach my $dir_code (
            sort { $a <=> $b }
            keys %{ $stopinfo{$stop}{$linegroup} }
          )
        {

            foreach my $days (
                sort keys %{ $stopinfo{$stop}{$linegroup}{$dir_code} }
              )
            {

                print $out "$linegroup\t$dir_code\t$days";
                
                my $note = $note_of{"$stop:$linegroup:$dir_code:$days"}{NOTE};
                if ($note)  {
                    print $out "\t#$note\t";
                    print $out $note_of{"$stop:$linegroup:$dir_code:$days"}{INFO};
                } 
                else {
                foreach my $time_r (
                    @{ $stopinfo{$stop}{$linegroup}{$dir_code}{$days} } )
                {

                    #print "$stop:$linegroup:$dir_code:$days\n";
                    print $out "\t", join(
                        ':',
                        $time_r->{TIME},        $time_r->{LINE},
                        $time_r->{DESTINATION}, $time_r->{PLACE},
                        $time_r->{DAYEXCEPTIONS}
                    );

                }
 
                }
                print $out "\n";

            } ## <perltidy> end foreach my $days ( sort { $daysort...})

        } ## <perltidy> end foreach my $dir_code ( sort...)

    } ## <perltidy> end foreach my $linegroup ( sort...)

    close $out or die $!;

} ## <perltidy> end foreach my $stop ( keys %stopinfo)

print "\nDone.\n";

sub makestoptimes {
    my %avldata = %{ +shift };

    my %stopinfo;

  TRIP:
    while ( my ( $trip_number, $trip_of_r ) = each %{ $avldata{TRP} } ) {
        my %tripinfo_of = %{$trip_of_r};
        next TRIP unless $tripinfo_of{IsPublic};

        my $line = $tripinfo_of{RouteForStatistics};
        next TRIP if $line eq '399';    # supervisor order

        #$line = '1' if $line eq '1Lx';
        #$line = '51' if $line eq '51S';

        my $linegroup = linegroup($line);

        my $pattern = $tripinfo_of{Pattern};
        my $patkey = key( $line, $pattern );

        my $days = $tripinfo_of{OperatingDays} ;
        $days =~ tr/0-9//cd; # strip everything but digits

        #my $hdays = $tripinfo_of{OperatingDays} ;
        #my $days = $DAY_OF{ $hdays };
        #warn "unrecognized days $hdays in line $line" unless $daysort{$days};
        my $dir_code = $avldata{PAT}{$patkey}{DirectionValue};

        my @tps         = @{ $avldata{PAT}{$patkey}{TPS} };
        #my $final_tps   = $tps[-1];
        my $final_tps   = pop @tps;
        my $final_place = remove_place_suffixes($final_tps->{Place});

      TIMEIDX:
        #foreach my $timeidx ( 0 .. $#{ $tripinfo_of{PTS} } - 1 ) {
        # from first to penultimate stop
        # Commented out to add last stop back

        foreach my $timeidx ( 0 .. $#{ $tripinfo_of{PTS} }  ) {
            my $stop = $avldata{PAT}{$patkey}{TPS}[$timeidx]{StopIdentifier};

            next TIMEIDX if $stop =~ /^D/i;

            my $place = $avldata{PAT}{$patkey}{TPS}[$timeidx]{Place};
            $place = remove_place_suffixes($place);

            my $time = $tripinfo_of{PTS}[$timeidx];
            $time =~ s/^0//;

            push @{ $stopinfo{$stop}{$linegroup}{$dir_code}{$days} }, {
                TIME          => $time,
                DESTINATION   => $final_place,
                LINE          => $line,
                PLACE         => $place,
                DAYEXCEPTIONS => '',             # TODO add later
            };

        }

    } ## <perltidy> end while ( my ( $trip_number...))

    return %stopinfo;

} ## <perltidy> end sub makestoptimes

sub linegroup {
    return wantarray ? @_ : $_[0];

    # at the moment, simply returns its arguments.
    # At some point we will want to change this,
    # to allow for joining lines into linegroups.
    # But not today.

}

sub remove_place_suffixes {
   my $place = shift;
   $place =~ s/-[AD12]$//;
   return $place;
}

=head1 NAME

avl2points - makes list of times that buses pass each stop';

=head1 DESCRIPTION

avl2points reads the data written by readavl and turns it into 
a list of times that buses pass each stop.
It is saved in the directory "kpoints" in the directory for that signup.

=head1 AUTHOR

Aaron Priven

=cut

