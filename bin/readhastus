#!/usr/bin/perl

#00000000111111111122222222223333333333444444444455555555556666666666777777777
#23456789012345678901234567890123456789012345678901234567890123456789012345678

use warnings;
use strict;
use Carp;

# set some constants
use Readonly;
Readonly my $EMPTY_STR => q{};
Readonly my $CRLF => qq{\cM\cJ};
Readonly my $KEY_SEPARATOR => qq{\c]}; # control-]
Readonly my $NO_PARENT => q{top};



# set up field hashes
my %field_names_of;
my %keys_of;
my %parent_row_type_of;
my %is_used;
my %data;
my %uses_key;
my %has_repeating_final_field;
my %is_a_parent;

#
# read field names from the DATA segment
#
{ 
local $/ = $EMPTY_STR; # paragraphs

READ_FIELD_NAMES:
while (<DATA>) {
   chomp;

   # get field names, whether we use this kind of row, if it has a parent
   my @field_names = split;
   my ($use_row, $parent_row_type) = splice @field_names, 1, 2, ();
   my $row_type = $field_names[0];

   # save whether it's used or not
   $is_used{$row_type} = ($use_row eq 'yes');
   
   $is_a_parent{$parent_row_type} = 1;
   
   next READ_FIELD_NAMES unless $is_used{$row_type};

   # if final field is repeating, save that

   $has_repeating_final_field{$row_type} = $field_names[-1] =~ /\*\z/;

   if ($has_repeating_final_field{$row_type}) {
       $field_names[-1] =~s/\*\z//; # remove * marker
   }
  
   # identify which fields are keys, if any
   for my $field_name (@field_names) {
       if ($field_name =~ /\!\z/) {
          $field_name =~ s/!\z//;
          push @{$keys_of{$row_type}} , $field_name;
       }
   }
   $uses_key{$row_type} = exists $keys_of{$row_type};
   
   # save info of this row_type in main hashes
   $field_names_of {$row_type} = [ @field_names ];
   $parent_row_type_of{$row_type} = $parent_row_type;

   # die if the "do I use this" answer isn't yes or no
   $use_row = lc($use_row);
   if ($use_row ne 'yes' and $use_row ne 'no') {
      die q{Don't know whether I should use or not use }
          . qq{$row_type rows when the answer is $is_used{$row_type}};
   }
   
}
} # scoping of $/


#
# get the filenames
#

# TODO - make a filename scheme that actually works, 
# probably everything in $skedsdir/hastusfiles or something like that
# (once I take the skedfile module)

# get filenames and put them in ARGV so that <> can iterate over them
@ARGV = 
   glob ("~/Desktop/actfall07b/23082007*");
#   glob "~/Documents/Work/AC Transit/hastus/actfall07b/23082007*");

# read rows
{

my %previous_of_r;
local $/ = $CRLF;

my $prevargv = "";

ROW:
while (<>) {

   if ($prevargv ne $ARGV) {
      print "$ARGV\n" ;
   }
   
   $prevargv = $ARGV;

   # get row type and their fields
   chomp;
   
   # EVIL KLUDGE TO COPE WITH NOT-REALLY-CSV FILES
   
   s/,C,V,PKRD,/,C.V.PKRD,/;
   
   my @fields = split (/,/);
   stripblanks(@fields);
   my $row_type = $fields[0];
   next ROW if (not $is_used{$row_type});

   my %this_row;

   # assign fields to hash.
   
   # TODO - modify so if there's only one field, it doesn't
   # use a hashref
   
   my @field_names = @{$field_names_of{$row_type}};
   
   if ($has_repeating_final_field{$row_type}) {
   
      my $final_field_idx = $#field_names;
      my $final_field = $field_names[-1];
     
      # assign all but last field
	   for my $field_idx (1 .. $final_field_idx - 1) {
	      $this_row{$field_names[$field_idx]} 
	         = $fields[$field_idx];
	   }
	   
	   # assign last field: array of remaining fields
	   $this_row{$final_field} 
	      = [ @fields[ $final_field_idx .. $#fields ] ];
      
   }
   
   else { # no final repeating field
	   for my $field_idx (1 .. $#fields) {
	      $this_row{ $field_names[$field_idx] } 
	         = $fields[$field_idx];
	   }
	}

   my $parent_row_type = $parent_row_type_of{$row_type};


   # if there are key fields
   if ($uses_key{$row_type}) {
      
      # hash slice. Gets key fields of $this_row
	   my $key = join( $KEY_SEPARATOR , 
	                  @this_row{ @{$keys_of{$row_type}} } 
	                ); 
	                
	   # save into parent's hash, or $data if no parent
	   
	   if ($parent_row_type eq $NO_PARENT) {
	      $data{$row_type}{$key} = \%this_row;
	   }
	   else {
	      $previous_of_r{$parent_row_type}{$row_type}{$key} = \%this_row;
	   }
   
   } 
   else { # no key fields
   
      my $ref_to_save;
      # if there's only one field, and this isn't a parent row,
      if (scalar(keys(%this_row)) == 1 and not ($is_a_parent{$row_type})) {
         # save the values only
         $ref_to_save = $this_row{$field_names[1]}
      } else 
      {  
         # save the row
         $ref_to_save = \%this_row;
      }
      
      #$ref_to_save = \%this_row;
   
	   # save thisrow to %data if no parent
	   if ($parent_row_type  eq $NO_PARENT) {
	      push @{$data{$row_type}}, $ref_to_save;

	   } 
	   else { # has a parent
	      # save to previous row's hash
	      push @{$previous_of_r{$parent_row_type}{$row_type}}, $ref_to_save;
	   }
   }
   
   # save this row so that if it is the parent of something,
   # its child can be saved in the right place
   $previous_of_r{$row_type} = \%this_row;

} 
continue {
   # resets line numbering for errors
   close ARGV if eof;
}
} # scoping $/


exit;           


sub stripblanks {
   
   carp q{stripblanks called from non-void context}
      if defined wantarray;
   foreach (@_) {
       s/^\s+//; 
       s/\s+$//;
   }
   return;
}


__DATA__
CAL no  top StartDate EndDate SchedulingUnit ScheduleSet

DAT no  CAL Date! SchedulingUnit! CrewScheduleName CrewScheduleType
CrewScheduleTypeValue CrewScheduleScenario CrewScheduleBooking
VehicleScheduleName VehicleScheduleType VehicleScheduleTypeValue
VehicleScheduleScenario VehicleScheduleBooking

STP yes top Identifier! Description Place XCoordinate YCoordinate
IntersectingStreetAtSegmentBeginning IntersectingStreetAtSegmentEnd
DistanceToIntersection SegmentOffset District Zone IsPublic
DistanceFromIntersectionAtBeginning DistanceFromIntersectionAtEnd

PLC yes top Identifier! Description ReferencePlace District Number
AlternateName XCoordinate YCoordinate

PPAT yes top Route! Direction DirectionValue!
RouteMainPlacePatternDirection RouteMainPlacePatternPlace*

DIS no top StartStop! EndStop! Distance

SHA no DIS ignore XCoordinate YCoordinate

RTE yes top Identifier! PublicIdentifier ServiceType ServiceTypeValue
ServiceMode ServiceModeValue

PAT yes top Route! Identifier! Direction DirectionValue VehicleDisplay
IsInService Via ViaDescription

TPS yes PAT StopIdentifier Place VehicleDisplay IsATimingPoint
IsRoutingPoint

VDC no top Identifier AlternateCode Message1 Message2 Message3 Message4 

VSC no top Name! ScheduleType ScheduleTypeValue! Scenario! Booking!
SchedulingUnit Description

BLK no VSC Number! InternalNumber OperatingDays! StartPlace StartTime!
InServiceStartPlace InServiceStartTime InServiceEndPlace InServiceEndTime
EndPlace EndTime VehicleGroup VehicleType VehicleNumber

TIN no BLK InternalNumber

TRP yes top InternalNumber! Number OperatingDays RouteForStatistics Pattern
Type TypeValue IsSpecial IsPublic

PTS yes TRP PassingTime

CSC no top Name! ScheduleType ScheduleTypeValue! Scenario! Booking!
SchedulingUnit Description

PCE no CSC DutyIdentifier InternalNumber DutyOperatingDays
BlockInternalNumber Position! ReportPlace ReportTime StartPlace StartTime
EndPlace EndTime ClearPlace ClearTime

ASG no top EffectiveStartWeek Division

RAS no ASG RosterSetIdentifier! RosterIdentifier! PositionIdentifier!
SequenceInWeek! CurrentDate DutyInternalNumber EmployeeIdentifier

EMP no top Identifier! Fullname DisplayIdentfier

DWP no top DutyNumber! BlockNumber! EmployeeDisplayIdentifier StartPlace
StartTime ReportPlace ReportTime EndPlace EndTIme ClearPlace ClearTime
