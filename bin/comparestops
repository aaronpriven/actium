#!/usr/bin/perl

@ARGV = qw(-s sp10 -o w09) if $ENV{RUNNING_UNDER_AFFRUS};

# comparestops - see POD documentation below

#00000000111111111122222222223333333333444444444455555555556666666666777777777
#23456789012345678901234567890123456789012345678901234567890123456789012345678

use warnings;
use strict;

# add the current program directory to list of files to include
use FindBin('$Bin');
use lib ($Bin , "$Bin/../bin");

use Carp;
#use Fatal qw(open close);
use Storable();

use Actium( qw[add_option initialize avldata sayq chdir_signup option]);
use Actium::Constants;
use Actium::Union('ordered_union');
use List::MoreUtils('uniq');

# don't buffer terminal output
$| = 1;

my $helptext = <<'EOF';
avl2stoplists reads the data written by readavl.
It then assembles a list of stops and the routes that stop at each one.
Finally, it displays a list of new, deleted, and changed stops.
See "perldoc comparestops" for more information.
EOF

my $intro = 'comparestops -- compare old and new stops from AVL data';

add_option('oldsignup=s'
   , 'The older signup. The program compares data from the this signup to the one'
   . 'specified by the "signup" option.'
   );

Actium::initialize ($helptext, $intro);

my %newstoplists = assemble_stoplists();

open my $out, '>' ,  'comparestops-dir.txt';
# done here so as to make sure the file is saved in the *new*
# signup directory

print $out "StopID\tStop Description\tAdded\tRemoved\tUnchanged\n";

chdir_signup ('oldsignup', 'ACTIUM_OLDSIGNUP' , 'old signup');

my %oldstoplists = assemble_stoplists();

my @stopids = uniq ( sort (keys %newstoplists, keys %oldstoplists) );

my %changes;

STOPID:
foreach my $stopid (@stopids) {

   if (not exists $oldstoplists{$stopid} ) {
      push @{$changes{ADDEDSTOPS}}, $stopid;
      next STOPID;
   }
   
   if (not exists $newstoplists{$stopid} ) {
      push @{$changes{DELETEDSTOPS}}, $stopid;
      next STOPID;
   }
   
   my @oldroutes = sort keys %{ $oldstoplists{$stopid}{Routes} };
   my @newroutes = sort keys %{ $newstoplists{$stopid}{Routes} };
   
   next STOPID if (join ('', @oldroutes)) eq (join('', @newroutes ));
   # no changes
   
   my (@added, @removed, @unchanged);

   COMPONENT:
   foreach my $component ( Algorithm::Diff::sdiff (\@oldroutes, \@newroutes) ) {
   
      my ($action, $a_elem, $b_elem) = @$component;
      
      if ($action eq 'u') {
         #push @{$changes{CHANGEDSTOPS}{$stopid}{UNCHANGED}} , $a_elem;
         push @unchanged, $a_elem;
      } 
      
      if ($action eq 'c' or $action eq '-') {
         #push @{$changes{CHANGEDSTOPS}{$stopid}{REMOVED}} , $a_elem;
         push @removed, $a_elem; 
      }
      
      if ($action eq 'c' or $action eq '+') {
         #push @{$changes{CHANGEDSTOPS}{$stopid}{ADDED}}   , $b_elem;
         push @added, $b_elem; 
      }
      
   }# COMPONENT
   
   if (not @removed) {
      $changes{ADDLINES}{$stopid}{ADDED} = \@added; 
      $changes{ADDLINES}{$stopid}{UNCHANGED} = \@unchanged;
   } 
   elsif (not @added) {
      $changes{REMOVEDLINES}{$stopid}{REMOVED} = \@removed; 
      $changes{REMOVEDLINES}{$stopid}{UNCHANGED} = \@unchanged;
   }
   else {
      $changes{CHANGEDSTOPS}{$stopid}{ADDED} = \@added; 
      $changes{CHANGEDSTOPS}{$stopid}{REMOVED} = \@removed; 
      $changes{CHANGEDSTOPS}{$stopid}{UNCHANGED} = \@unchanged;
      
   }

}# STOPID


print $out "Added stops: " , scalar @{$changes{ADDEDSTOPS}} , "\n";

foreach my $added_stopid  (sort @{$changes{ADDEDSTOPS}}) {
   print $out $added_stopid , "\t" , $newstoplists{$added_stopid}{Description} , "\t"
         , join (',' , sort keys %{$newstoplists{$added_stopid}{Routes}}) , "\n";
}

print $out "\nRemoved stops: " , scalar @{$changes{DELETEDSTOPS}} , "\n";

foreach my $deleted_stopid  ( sort @{$changes{DELETEDSTOPS}}) {
   print $out $deleted_stopid , "\t" , $oldstoplists{$deleted_stopid}{Description} , "\t\t"
         , join (',' , sort keys %{$oldstoplists{$deleted_stopid}{Routes}}) , "\n";
}

output_stops ('Stops with added lines' , $out, 'ADDLINES');

output_stops ('Stops with removed lines' , $out, 'REMOVEDLINES');

output_stops ('Stops with changed lines' , $out, 'CHANGEDSTOPS');

sayq "Completed comparison.";

sub output_stops {
   my $desc = shift;
   my $fh = shift;
   my $type = shift;
   
   my %thesestops = %{$changes{$type}};
   
   print $fh "\n$desc: " , scalar keys %thesestops , "\n";
   
   foreach my $stopid  ( sort keys %thesestops) {

      print $fh $stopid , "\t" , $oldstoplists{$stopid}{Description};

      if (exists $changes{$type}{$stopid}{ADDED} ) {
         my @added = sort @{$changes{$type}{$stopid}{ADDED}};
         print $fh "\t", join (',' , @added);
      } 
      else {
         print $fh "\t";
      }

      if (exists $changes{$type}{$stopid}{REMOVED}) {
         my @removed = sort @{$changes{$type}{$stopid}{REMOVED}};
         print $fh "\t" , join (',' , @removed);
      }
      else {
         print $fh "\t";
      }
   
      if (exists $changes{$type}{$stopid}{UNCHANGED} ) {
         my @unchanged = sort @{$changes{$type}{$stopid}{UNCHANGED}};
         print $fh "\t" , join (',' , @unchanged);
      }
      else {
         print $fh "\t";
      }

      print $fh "\n";   
   
   }

   
  return; 
   
}



sub assemble_stoplists {

   my %stoplist = ();
   
	my (%pat, %stp);

	{ # scoping
	# the reason to do this is to release the %avldata structure, so Affrus 
	# (or, presumably, another IDE)
	# doesn't have to display it when it's not being used. Of course it saves memory, too

	my $avldata_r = avldata();

	%pat = %{$avldata_r->{PAT}};

	%stp = %{$avldata_r->{STP}};

	}

	PAT:
	foreach my $key (keys %pat) {

	   my $dir = $pat{$key}{DirectionValue};
	   next unless exists($DIR_OF{$dir});
	   $dir = $DIR_OF{$dir};

	   my $route = $pat{$key}{Route};
	   
	   next if $route eq 'NC' or $route eq 'LC' or $route eq '678' or $route eq '51S';

	   foreach my $tps_r ( @{$pat{$key}{TPS}}) {
	       my $stopid = $tps_r->{StopIdentifier};
	       next if $stopid =~ /^D/i;
	       
	       $stoplist{$stopid}{Routes}{"$route-$dir"} = 1;
	       #$stoplist{$stopid}{Routes}{$route} = 1;
	       $stoplist{$stopid}{Description} = $stp{$stopid}{Description};
	       
	   }

	}
	
	return %stoplist;

}


=head1 NAME

comparestops - Compares the stops from two sets of AVL files.

=head1 DESCRIPTION

comparestops reads the data written by readavl.
It then assembles a list of stops and the routes that stop at each one.
Finally, it displays a list of new, deleted, and changed stops.

=head1 AUTHOR

Aaron Priven

=cut
