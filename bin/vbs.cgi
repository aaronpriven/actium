#!/usr/bin/perl5require ('/home/priven/public_html/cgi-lib.pl');&ReadParse;# get data from form$linenum = $in{"linenum"};$dirname = $in{"dirname"};$direction = $in{"direction"};$pickedpoint = $in{"pickedpoint"};$offset = $in{"offset"};$totallines = $in{"totallines"};$pickedpoint--;# you pick a 1-based number, but the program needs a 0-based number$chosenlines = 0;if ($totallines) {# if there's more than one line,   @alllines = split (":", $in{"alllines"} );   $checkline = $in{"checkline"};   if ($checkline) {      # if the user has checked at least one box,         @lines = split("\0", $checkline);      $chosenlines = 1 unless scalar(@lines) == scalar(@alllines);   } else {   # the user checked no boxes, which is the same as checking all boxes.      @lines = @alllines;   }# OK, after that $chosenlines is true if the user wants only some of# the lines.  The lines the user wants are in @lines, in order of most common,# and all the lines in the schedule are in @alllines whether we want them or not.       @alphalines = sort @lines;# that puts the lines in alphabetical order    if ($#lines > 1 ) {            $linesstring = "Lines ";                foreach (0 .. $#lines - 1) {            $linesstring .= "$alphalines[$_], ";        }        $linesstring .= "and $alphalines[$#lines]";        } elsif ($#lines == 1) {        $linesstring = "Lines $alphalines[0] and $alphalines[1]";    } else {        $linesstring = "Line $alphalines[0]";    }# That creates the line display that the user sees.} else {#there's only one line in the schedule.   $linesstring = "Line $linenum";   @alllines = $linenum;   @lines = $linenum;}open TEMPFILE, "</tmp/priven-vbs/$direction";$numpoints = <TEMPFILE>;foreach (0 .. $numpoints) {   $timepoint = <TEMPFILE>;#   $null = <TEMPFILE>;   # that just throws away the next input line.  I don't understand it.   # nothing I can see indicates why blank lines keep getting input.   # nonetheless, they are.   ($code, $timepoint) = split ("\0" ,$timepoint,  2);   chomp($timepoint);   push @codes, $code;   push @timepoints, $timepoint;}# OK, we now have @codes and @timepoints back.$null = <TEMPFILE>;$null = <TEMPFILE>;#those are the timepoint info at the top, which we will throw away.@sched = <TEMPFILE>; # love that "read a whole file with one line" thingclose TEMPFILE;####################### NOTE AND LINE PREPROCESSING ########################## This figures out how many notes and lines there are, and which characters# should be used for them.@notechars = split (//, '*+=#%$-@&?!^bcdefghijklmnoqrstuvwxyzBCDEFGHIJKLMNOQRSTUVWXYZ');# those are the characters we will use for notes. I hope we never get that many! # if we get into letters we are in trouble, but I omitted the following to avoid confusion# with the AM/PM markers: a, A, p, Pif ($totallines) {   # line processing      foreach (1 .. $#lines) {      # starts at 1 because we don't need a note for the most common line         &getnotechar ($lines[$_], "Line $lines[$_]");   }   }if ($offset == 3 or $offset == 8) {   # notes processing         %notetext = ("SD" => "School days only" , "SH" => "School holidays only");      foreach (@sched) {   #### This is BROKEN. It only deals with the notes "SD" and "SH." To work properly,#### it should assemble all the notes from the bottom of the schedule and#### tag them properly. I haven't tried, since with the 10/10/99 schedules#### I can't find any other notes, and there doesn't seem to be an easy way of identifying#### the note lines at the bottom. The "will carry a bike" notes seem to have#### disappeared.      $thisnote = substr ($_,0,3);      $thisnote =~ s/\s//g;      $thisnote =~ tr/a-z/A-Z/;      next unless $thisnote;      $notecounts{$thisnote}++;   }      # so now all the notes are the keys of %notecounts      foreach (keys %notecounts) {            delete $notecounts{$_} unless /^S[HD]$/;      # see? I said it was broken. Any other notes will just not be found         }   if (keys %notecounts) {   # if there are any notes,           $hasnotes = 1;      @notes = sort { $notecounts{$b} <=> $notecounts{$a} } keys(%notecounts);       # that makes @notes the list of valid notes (at the moment, only SH and SD),      # sorted by how many there are.               foreach (@notes) {                        &getnotechar ($_, $notetext{$_});      }   }}print "Content-type: text/html\n\n";print "<title>Vigilante Bus Schedules: Line $linenum</title>\n";print "<h2>$linesstring</h2><p>$dirname for<br>$timepoints[$pickedpoint]</p>\n";print "<hr><pre>\n";foreach (@sched) {      $mysched = substr ($_, 6 * $pickedpoint + $offset, 6);        $mysched =~ s/\s//g;   if ($totallines) {      $myline = substr($_, $offset-5 , 5);       $myline =~ s/\s//g;      $myline =~ tr/a-z/A-Z/;      $linetoprint = grep ($_ eq $myline, @lines);        # if there's a better way to say "is this scalar an element in that list"      # I don't know it.       } else {         $linetoprint = 1;         }      if ($mysched and $linetoprint) {      print $mysched;      if ($hasnotes) {         # this file has notes               $thisnote = substr($_, 0, 3);         $thisnote =~ s/\s//g;         $thisnote =~ tr/a-z/A-Z/;               print $notechars{$thisnote} if $thisnote;      }            if ($totallines and ($myline ne $lines[0]) ) {               print $notechars{$myline};            }            print "\n";   }}print "</pre></p>\n";if ($#lines or $hasnotes) {       print "<p>Unless marked, times are for line $lines[0].</p>\n" if $totallines;    print "<p>Notes:</p>\n<p>";       foreach (sort keys %bottomnote) {              print "$notechars{$_}  $bottomnote{$_}<br>\n";           }           print "</p>\n";   }   sub getnotechar {   my $thisnote = $_[0];   my $thisbottom = $_[1];   return $notechars{$thisnote} if $notechars{$thisnote};      # so if we've already assigned a $notechars, use it   # the rest is to pick a new notechar that's relevant   my $thischar = $notechars[$lastnotechar];      $lastnotechar++;   $notechars{$thisnote} = $thischar;      # assign this note      $bottomnote{$thisnote} = $thisbottom;   # assign this bottom line   return $thischar;   # I don't expect to use that but what the hell}