#!/usr/bin/perl
# vimcolor: #000030

# makepoints
#
# This program generates the point schedules associated with 
# particular signs.

use strict;

# initialization

use FindBin('$Bin'); 
   # so $Bin is the location of the very file we're in now

use lib $Bin; 
   # there are few enough files that it makes sense to keep
   # main program and library in the same directory

# libraries dependent on $Bin

use FPMerge qw(FPread FPread_simple);
use Skedfile qw(Skedread);
use Skeddir;
use Skedvars;
use Skedtps qw(%tphash %tpxref);
use Byroutes 'byroutes';
use Myopts;

my %options;
Myopts::options (\%options, Skeddir::options(), 'quiet!');
# command line options in %options;

$| = 1; # this shouldn't be necessary to a terminal, but apparently it is

print <<"EOF" unless $options{quiet};
makepoints - This is the makepoints program. It creates point schedules
from the data exported from the FileMaker databases.

EOF

my $signup;
$signup = (Skeddir::change (\%options))[2];
# Takes the necessary options to change directories, plus 'quiet', and
# then changes directories to the "Skeds" base directory.

# open and load files

print "Using signup $signup\n\n" unless $options{quiet};

print <<"EOF" unless $options{quiet};
Now loading data...
EOF

# read in FileMaker Pro data into variables in package main

our (@signs, @stops, @lines, @skedspec);
our (%signs, %stops, %lines, %skedspec);

our ($schooldayflag, $anysecondflag);

print "Timepoints and timepoint names... " unless $options{quiet};
my $vals = Skedtps::initialize;
print "$vals timepoints.\nSigns... " unless $options{quiet};

FPread_simple ("Signs.csv" , \@signs, \%signs, 'SignID');
print scalar(@signs) , " records.\nSkedspec... " unless $options{quiet};
FPread ("SkedSpec.csv" , \@skedspec, \%skedspec, 'SignID' , 1, 0);
# ignores repeating fields, but works with non-unique SignIDs
# BUG - rest of program will break if there are *not* non-unique SignIDs.
# Not a problem in real life, but may break simple test runs.
print scalar(@skedspec) , " records.\nLines... " unless $options{quiet};
FPread_simple ("Lines.csv" , \@lines, \%lines, 'Line');
print scalar(@lines) , " records.\nStops (be patient, please)... " unless $options{quiet};
FPread_simple ("Stops.csv" , \@stops , \%stops , 'UNIQUEID');
print scalar(@stops) , " records.\nLoaded.\n\n" unless $options{quiet};

open DATE , "<effectivedate.txt" 
      or die "Can't open effectivedate.txt for input";

our $effdate = scalar <DATE>;
close DATE;
chomp $effdate;

# main loop

print "Now processing point schedules for sign number:\n" 
    unless $options{quiet};

my $displaycolumns = 0;


my @signstodo;

if (@ARGV) {
   @signstodo = @ARGV;
} else {
   @signstodo = keys %signs;
}


SIGN:
foreach my $signid (sort {$a <=> $b} @signstodo) {

   next SIGN unless $signs{$signid}{Active} and exists $skedspec{$signid};
   # skip inactive signs and those without skedspecs
   
   unless ($options{quiet}) {
      $displaycolumns += length($signid) + 1;
      if ($displaycolumns > 70) {
         $displaycolumns = 0;
         print "\n";
      }
      print "$signid ";
   }

   $schooldayflag = 0;
   $anysecondflag = 0;
   
   my @points = ();
   
   SCHEDULE:
   foreach my $skedspec (@{$skedspec{$signid}} ){
      next SCHEDULE if $skedspec->{FullOrPoint} eq 'Full';
      push @points, build_point($skedspec); # returns a hashref to the point sked
   }

   output_points(\@points , $signid) if scalar (@points);
   # output the point sched unless there are no points
   # (which would be the case if there are only full schedules here)

}

print "\n\n" unless $options{quiet};

sub build_point {

   my $skedspec = shift;

   my $point = Skedread("skeds/" . $skedspec->{'SkedID'} . "-s.txt");
   # now $point includes all the data in the full schedule
   # This includes 
   # DAY, DIR, SKEDNAME, LINEGROUP (scalars)
   # TP, NOTEDEFS, NOTES, SPECDAYS, and ROUTES (arrays)
   # TIMES (array of arrays)

   foreach (keys %$skedspec) {
      $point->{$_} = $skedspec->{$_};
   }

   # now $point includes all the data in Skedspec, too! 
   # This includes Timetable, Lines, Timepoint, LastStop, ExactTP,
   # SecondTimepoint, UseSecondTimepoint, BlankTimepoint, BlankorNonBlank,
   # AmPm, FullOrPoint, SkedID, SignID, SkedSpecSerial, TPXref,
   # BlankTPXref, SecondTPXref, Day, Dir, TPXrefName, Timepoint_NoEquals,
   # BlankTP_NoEquals, SecondTP_NoEquals

   # Some of these will be blank because they are calculated fields not
   # stored

   {
   my $i=0;
   $point->{TPNUM}{$_} = $i++ foreach @{$point->{TP}};
   } # calculates timepoint column numbers

   $point->{TPNUM2USE} = $point->{TPNUM}{$point->{Timepoint}} ;

   $point->{DOSECOND} = 0;
   if ( lc($point->{UseSecondTimepoint}) eq "yes" ) {
      $point->{S_TPNUM2USE} = $point->{TPNUM}{$point->{SecondTimepoint}};
      unless ($point->{S_TPNUM2USE} == $point->{TPNUM2USE}) {
         $point->{DOSECOND} = 1;
         $anysecondflag = 1;
      }
   }

   $point->{ROUTES2USE} = [ (split "\n" , $point->{Lines}) ];

   $point->{NOTEKEYS} = note_definitions($point);
   # now all the routes and note keys are in the hash 
   # %{$point->{NOTEKEYS}}
   
   build_used($point);  

   # Now we know that usedrow(x) is 1 if the xth row is a valid one,
   # an 0 if it should be skipped. 

   # We also just built $point->{USED}..., which are 
   # the frequency of routes, notes, and special days used

   # and we also just built $point->{LASTTP}


   { # block for scoping
   my $temp = $point->{M_TIMEPOINT};
   $temp =~ s/=\d+$//; # eliminate trailing equals signs and digits
   $point->{M_TPXREF} = $tpxref{$temp};
   }

   $point->{HEADNUM} = [sort byroutes @{$point->{ROUTES2USE}}];
   # in the old windows version, there was a long routine that
   # combined things like 51/51A into a single number (51). 
   # I decided not to do that anymore
   
   ( $point->{DAY2USE} , $point->{HEADDAYS} ) = 
       headdays ($point);
   # get the header day text ("Mon thru Fri", etc.) 

   ($point->{LASTTP2USE} , $point->{HEADDEST}) = headdest ($point);
   # get the header destination text ("To University and San Pablo")
   # $...{LASTTP2USE} is the timepoint short string ("UNIV S.P.")
   # also puts the various non-default last tps into {NOTEKEYS}
   
   return $point;

}

sub note_definitions ($) {

   my $point = shift;

   my %notekeys = ();

   foreach (@{$point->{"NOTEDEFS"}}) {
      my ($key, $notedef) = split(/:/);
      $notedef =~ s/ only//i;
      $notekeys{$key} = $notedef;
   }
   # Now all the note definitions from here are in
   # the notekeys hash

   $notekeys{$_} = "Line $_" foreach ($point->{ROUTES2USE}) ;
   # that puts the routes in Notekeys too

   return \%notekeys;

} 

sub build_used {
   
   my $point = shift;

   my (%routes, $doblank, $blanktpnum, $dosecond , $s_tpnum);

   my $tpnum = $point->{TPNUM2USE};

   # is there a second timepoint as well as the first?

   $dosecond = 0;
   if ($point->{DOSECOND}) {
      $dosecond = 1; # it's easier to have a flag than to keep using "exists"
      $s_tpnum = $point->{S_TPNUM2USE};
   }

   # the following implements the "blank or nonblank" thing

   $doblank = 0; 
   if ( lc($point->{BlankorNonBlank}) eq "blank" ) {
      $doblank = -1; 
   } elsif ( lc($point->{BlankorNonBlank}) eq "nonblank" ) {
      $doblank = 1;
   }

   if ($doblank and exists ( $point->{TPNUM}{$point->{BlankTimepoint}} ) ) {
      # if the user specified that we're to look for blank timepoints,
      # and there is a valid timepoint number for that entry
      $blanktpnum = ($point->{TPNUM}{$point->{BlankTimepoint}} ) ;
      # $blanktpnum is the one we're looking at.
      $doblank = 0 if $blanktpnum == $tpnum;
      # but don't do it if the blanktp is the same as this timepoint,
      # since that makes no sense.
   } else {
      $doblank = 0;
      # otherwise, the user specified an invalid "blank" timepoint, and
      # thus we just pretend the user didn't ask for us to look at it.
   }

   my %used = ();

   local ($_);

   $point->{USEDROWS} = undef; # must initialize it for vec

   $routes{$_}=1 foreach (@{$point->{"ROUTES2USE"}}) ;

   # provides an easy "is an element" lookup

ROW: 
   for (my $row = 0; $row < scalar @{$point->{"ROUTES"}};
            $row++) {

      next ROW unless $routes{$point->{ROUTES}[$row]};
      # if this route isn't on the list of routes to use, skip this row
      # (so if we're printing out a 40 schedule, the 43 won't show up)

      my $thistpnum = $tpnum;
      if ($dosecond) {
         next ROW unless $point->{TIMES}[$tpnum][$row] or 
                         $point->{TIMES}[$s_tpnum][$row];
         $thistpnum = $s_tpnum unless $point->{TIMES}[$tpnum][$row];
      } else {
         next ROW unless $point->{TIMES}[$tpnum][$row];
      }
      # if there's no time for this row, skip it
      # now "$thistpnum" is the time we will actually use, whether it is
      # the main timepoint or the second timepoint
      # uses the first tpnum if both have times

      # the following implements the "am or pm" thing
      if ($point->{AmPm} =~ /a/i ) {
         next ROW unless $point->{TIMES}[$thistpnum][$row] =~ /a$/;
      } elsif ($point->{AmPm} =~ /p/i ) {
         next ROW unless $point->{TIMES}[$thistpnum][$row] =~ /p$/;
      }

      if ($doblank == 1)  { # not blank
         next ROW unless $point->{TIMES}[$blanktpnum][$row];
      } elsif ($doblank == -1) { # blank
         next ROW     if $point->{TIMES}[$blanktpnum][$row];
      }

      my $lasttpnum;
      TPS: 
      for ( my $i = ((scalar @{$point->{TP}}) -1 ); 
                $i >= 0;  $i-- ) {

          $lasttpnum = $i;
          last TPS if $point->{TIMES}[$i][$row];
      }
      # so $lasttpnum = the number of the last timepoint for which
      # there is a time

      $point->{LASTTP}[$row] = 
                $point->{TP}[$lasttpnum];

      # save the lasttp abbrev for when we figure out where the destination is

      next ROW if $lasttpnum == $thistpnum;
      # Skip this time if it's the last one in the row.
      # We don't want to tell people when buses leave from this point
      # if they go no further from here

      # ok, now we know this time should be included in the printed output

      vec ($point->{"USEDROWS"} , $row, 1) = 1;

      # and that's saved in $point->{"USEDROWS"}, which is
      # more easily accessed by the subroutine usedrow($point, $row)

      # OK, now we're going to go and build a new set of used variables.
      # These are the *frequency* of the NOTES, SPECDAYS, and ROUTES
      # thingies in the used rows.

      $_ = $point->{NOTES}[$row];
      $_ = "BLANK" unless $_;
      $used{NOTES}{$_}++;

      # I'm pretty sure it won't matter if we don't turn "" to "BLANK"
      # but I'm not sure enough.

      $_ = $point->{SPECDAYS}[$row];
      $_ = "BLANK" unless $_;
      $used{SPECDAYS}{$_}++;

      $used{ROUTES}{$point->{ROUTES}[$row]}++;
      # ROUTES will never be blank.

      if ($dosecond) {
         if ($thistpnum == $tpnum) {
            $used{TP}{Timepoint}++;
         } else {
            $used{TP}{SecondTimepoint}++;
         }
      }
      # this is whether the main timepoint or the second timepoint 
      # is more frequent

   }

   # save USED array in $point
   $point->{USED} = \%used;

   if ($dosecond) {
      if ($used{TP}{Timepoint} >= $used{TP}{SecondTimepoint}) {
         # if the first timepoint is more common than the second one,
         $point->{FIRSTISMAIN} = 1;
         $point->{L_EXACT}     = $point->{ExactSecondTP};
         $point->{L_TIMEPOINT} = $point->{SecondTimepoint};
         $point->{L_TPNUM2USE} = $point->{S_TPNUM2USE};
         $point->{M_EXACT}     = $point->{ExactTP};
         $point->{M_TIMEPOINT} = $point->{Timepoint};
         $point->{M_TPNUM2USE} = $point->{TPNUM2USE};
         # "M" means "Main". "L" means "Lesser."
      } else {
         $point->{FIRSTISMAIN} = 0;
         $point->{L_EXACT}     = $point->{ExactTP};
         $point->{L_TIMEPOINT} = $point->{Timepoint};
         $point->{L_TPNUM2USE} = $point->{TPNUM2USE};
         $point->{M_EXACT}     = $point->{ExactSecondTP};
         $point->{M_TIMEPOINT} = $point->{SecondTimepoint};
         $point->{M_TPNUM2USE} = $point->{S_TPNUM2USE};
      }
   } else {
         $point->{FIRSTISMAIN} = 1;
         $point->{M_TIMEPOINT} = $point->{Timepoint};
         $point->{M_TPNUM2USE} = $point->{TPNUM2USE};
         $point->{M_EXACT} = $point->{ExactTP};
   }
   # if we combine two timepoints, and the second one is more frequent than
   # the first, make $point->{MAINTP} "S_" -- this is a prefix used later.
   # Otherwise, make it nothing.


   # put the most common route for each column in $point->{MAINROUTE}
   $point->{MAINROUTE} = 
      ( sort { $used{ROUTES}{$b} <=> $used{ROUTES}{$a} } 
             keys %{$used{ROUTES}})[0];

   return $point; # although we don't actually use the returned value

}

sub usedrow {
   my ($point, $row) = @_;
   return vec ($point->{"USEDROWS"} , $row, 1);
}

sub headdays {

   my $point = shift;

   my @used = keys %{$point->{USED}{SPECDAYS}};
   # now we have the used special days in @used

   my $daycode = $point->{"DAY"};
   my $daystring;

   if (scalar( @used ) == 1) {
   # if there's only one day present,

      if ($used[0] eq "BLANK") {
         # and it's blank, use the standard day text

         $daystring = $Skedvars::longdaynames{$daycode};

      } else {
         # if only one day, but it's not blank, use that.

         $daystring = $point->{NOTEKEYS}{$used[0]};
         $daycode = $used[0];
	 $schooldayflag = 1 if $daycode eq 'SD';

      }

   } else {

      # more than one kind of day, so use the standard.
      $daystring = $Skedvars::longdaynames{$daycode};

   }

#   return $daycode , $daystring , $schooldayflag;
   return $daycode , $daystring ;

}


sub headdest {

   # %tphash imported from Skedtps.pm

   my $point = shift;

   my (%lasttpfreq) = ();

   for (my $row = 0; 
            $row < scalar @{$point->{ROUTES}};
            $row++) {
      next unless usedrow($point, $row) and
            $point->{ROUTES}[$row] eq $point->{MAINROUTE};

      # skip it, unless this timepoint is used and the current 
      # route is the same as in $mainroute
      $lasttpfreq{$point->{LASTTP}[$row]}++;
   }

   # so now %lasttpfreq holds the frequency of the last timepoints
   # (for the most frequent route).

   my $lasttp = 
       (sort { $lasttpfreq{$b} <=> $lasttpfreq{$a} } 
        keys %lasttpfreq)[0];

   # so $lasttp is the most common last timepoint

   foreach (keys %lasttpfreq) {
      $point->{NOTEKEYS}{$_} = $tphash{$_};
   }

   my $hashlookuptp = $lasttp;
   $hashlookuptp =~ s/=[0-9]*//;

   return $lasttp, ($tphash{$hashlookuptp} or $hashlookuptp);

}


sub output_points {

   my @points = @{+shift};
   my $signid = shift;

   our ($schooldayflag);

   my ($head, $thismark, @thesemarks, 
       $route, $lasttp, $temp, 
       $ampm, @markdefs, %usedmarks);

   local ($_);

   my $markcounter = 0;

   @markdefs = ();

   mkdir "points" or die 'Can\'t make directory "points"'  unless -d "points";

   open OUT, ">points/$signid-" . $signs{$signid}{SignType} . "-" . 
                  scalar (@points) . ".txt";

   @points = sort 
       {
        byroutes ($a->{"HEADNUM"}[0], $b->{"HEADNUM"}[0]) or 
        $Skedvars::dirhash{$b->{"DIR"}} <=> $Skedvars::dirhash{$a->{"DIR"}} or
        $Skedvars::dayhash{$b->{"DAY"}} <=> $Skedvars::dayhash{$a->{"DAY"}}
       } @points;


   my ($defaultheadtp, $defaultheadtpexact, $justoneheadtp) 
       = get_head_timepoints (\@points);

   foreach my $point (@points) {

      $head = join ("/" , @{$point->{"HEADNUM"}});

      # TODO - change format here to the new headers style

      # the gobbeldygook in the print statements are the quark tags
      print OUT '@Column head:<';                                   # style

      print OUT 
            '*d(' , length($head) +1 , ',2)><z10><b-1>';  # drop cap
	                                                 # at smaller size

      print OUT 
            '<c"' , getcolor($point->{HEADNUM}[0]) , '">';   # color

      # at some point, we may want to do some other kind of formatting if
      # there are two or more head numbers.

      print OUT "$head " , '<b$><z$>';

      print OUT $point->{HEADDAYS} , " to " ,
                $point->{HEADDEST};

      @thesemarks = ();

      # add note to indicate that times refer to the first route
      # given (of one or more) if there are two or more headnums
 
      $_ = $point->{MAINROUTE};

      if ( scalar ( @{$point->{HEADNUM}}) > 1) {

        if ($usedmarks{"HEADNUM:$_"}) {
           $thismark = $usedmarks{"HEADNUM:$_"};
        } else {
           $thismark = ++$markcounter;
           $usedmarks{"HEADNUM:$_"} = $thismark;
           $markdefs[$thismark] = 
              "Unless indicated otherwise, times in this column " .
              "are for Line $_.";
        }

        push @thesemarks, $thismark;

      } 

      # add note to indicate that times refer to the proper timepoint
      # if not the same as the current timepoint

      $_ = $point->{M_TPXREF};

      if ($defaultheadtp ne $_) {
      # if the default end timepoint for the schedule as a whole 
      # isn't the same as the default end timepoint for this column only,
      # we need a head note.

         if ($usedmarks{"Timepoint:$_"}) {
            $thismark = $usedmarks{"Timepoint:$_"};
         } else {
            $thismark = ++$markcounter;
            $usedmarks{"Timepoint:$_"} = $thismark;
            $temp = $tphash{$_};
#            print "<<$_:$temp>> ";
            $temp =~ s/\.$//;
            $markdefs[$thismark] = 
               "Departure times are given for $temp." ;
            $markdefs[$thismark] .=
               " Buses may arrive somewhat later at this location."
               unless lc($point->{M_EXACT}) eq "yes";
         }
 
         push @thesemarks, $thismark;

      }

      print OUT "<V>" , join (",", sort {$a <=> $b} @thesemarks), "<V>" 
           if scalar (@thesemarks);
      #<V> is "superior" type

      print OUT "<\\c>"; # next column (really, next box)

      my $prev = "z";

      for (my $row = 0; 
            $row < scalar @{$point->{ROUTES}};
            $row++) 
      {

         next unless vec ($point->{USEDROWS} , $row, 1);

         local ($_) = $point->{"TIMES"}[$point->{TPNUM2USE}][$row];

         # find out if this one is main or lesser
         my $lesser = 0;
         if ($point->{DOSECOND}) { 
            $lesser = 1 if ($_ xor $point->{FIRSTISMAIN} );
            # so, if the first timepoint has a time but the first one
            # isn't main, or the first timepoint has no time and
            # the first one is main, then this row is lesser, not main.
            # Whew.
            $_ = $_ || $point->{"TIMES"}[$point->{S_TPNUM2USE}][$row];
         }

         print OUT "\r" unless $prev eq "z";

         $ampm = chop; 
         # removes last char from the time, and sets $ampm to be that char

         if ($ampm ne $prev) {
             print OUT ($ampm eq 'a' ? '@amtimes:' : '@pmtimes:' );
             $prev = $ampm;
             # $_ .= $ampm 
             # if you want to add the "a" or "p back, uncomment the line above
         }
         # if $ampm not the same as the last one, print the appropriate
         # style sheet spec, and set the previous to be this one

         substr($_, -2, 0) = ":";

         print OUT "\t$_";

         # footnotes on the time

         @thesemarks = ();

         # I am ignoring the bicycle note.

         $_ = $point->{SPECDAYS}[$row];

         if ($_ and ($_ ne $point->{"DAY2USE"})) {
         # if the special day mark for this row isn't blank, and it 
         # isn't the same as the special days for the whole column,
         # we need a note.

            if ($usedmarks{$_}) {
               $thismark = $usedmarks{$_};
            } else {
               $thismark = ++$markcounter;
               $usedmarks{"$_"} = $thismark;
               $temp = $point->{NOTEKEYS}{$_};
               $temp =~ s/Days/days/;
               $temp =~ s/Holidays/holidays/;
               $markdefs[$thismark] = "$temp only.";
            }
 
            push @thesemarks, $thismark;

         }
         
         # routes, last timepoint

         $_ = $point->{"ROUTES"}[$row];

         undef $route;
         undef $lasttp;
         $route = $_ if $_ ne $point->{MAINROUTE};
         # route is nothing if it's the same as the most common route,
         # otherwise it's the route from the row

         $_ = $point->{LASTTP}[$row]; 
         $lasttp = $_ if $_ ne $point->{"LASTTP2USE"};

         # $_ is $route plus $lasttp, with a colon in the middle if 
         # both are valid


         if ($route or $lasttp or $lesser) {
            # if there's a different route or last timepoint,

            $_ = "$route:$lasttp:$lesser";

# TODO

            my $hashlasttp = $lasttp;
            $hashlasttp =~ s/=\d+$//;
 
            if ($usedmarks{$_}) {
               $thismark = $usedmarks{$_};
            } else {
               $thismark = ++$markcounter;
               $usedmarks{$_} = $thismark;

               $markdefs[$thismark] = "";

               if ($route or $lasttp) {
                  if ($route) {
                      $temp = "Line $route";
                      $temp .= ", to " .
                              $tphash{$hashlasttp} if $lasttp;
   
                  } else {
                     $temp = "To $tphash{$hashlasttp}";
                  }
   
                  $temp =~ s/\.$//;
               
                  $markdefs[$thismark] = "$temp.";
               }

               if ($lesser) {

                  $temp = $tphash{$tpxref{$point->{L_TIMEPOINT}}};
                  $temp =~ s/\.$//;

                  $markdefs[$thismark] .= " " if $markdefs[$thismark];
                  $markdefs[$thismark] .= 
                     "Departure time is given for $temp." ;
                  $markdefs[$thismark] .=
                     " Buses may arrive somewhat later at this location."
                     unless lc($point->{L_EXACT}) eq "yes";
               }

            }

            push @thesemarks, $thismark;

         }

         print OUT "<V>" , join ("," , sort {$a <=> $b} @thesemarks), "<V>" 
             if scalar (@thesemarks);

      } # end of row

    print OUT '<\c>';  # next point marker

    } # end of point

    if (scalar(@points) < 7 ) {
       print OUT '<\c>' x (2 * ( 7 - scalar(@points)) );
       # if there are less than seven columns, print extra column
       # markers for the blank ones
    }

    print OUT '@noteheaders:Light Face = a.m.<\n><B>Bold Face = p.m.<B>';
    print OUT "\r";
    print OUT '@noteheaders:';

    if ( not ($anysecondflag) and $justoneheadtp ) { 
       print OUT 'Departure times are given for ';
    } else {
       print OUT 'Unless otherwise specified, departure times are given for ';
    }
    $_ = $tphash{$defaultheadtp};
    s/\&/and/;
    s/\.$//;
    print OUT "$_.";
    print OUT " Buses may arrive somewhat later at this location."
                unless $defaultheadtpexact eq "Yes";

    print OUT "\r";


#   SCHOOLDAYS
    if ($schooldayflag or $usedmarks{SD}) {

       print OUT "Trips that run school days only may not operate every day and will occasionally operate at times other than those shown. Supplementary service is available to all riders at regular fares.\r";

    }

    if (scalar @markdefs) {

       print OUT '@notedefs:';

       for (my $i = 1; $i < scalar (@markdefs); $i++) {

          print OUT "$i.\t" , $markdefs[$i] , "\r";

       }

    }

    print OUT '<\c>@bottomnotes:' , signdescription($signid) , ". ";

    print OUT "[$signs{$signid}{PrintNotes}] " if $signs{$signid}{PrintNotes};

    my ($mday, $mon, $year) = (localtime(time))[3..5];

#    $mon = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)[$mon];
    $mon = qw(Jan. Feb. March April May June July Aug. Sept. Oct. Nov. Dec.)[$mon];

    $year += 1900; # Y2K compliant

    my $prepdate = "$mon $mday, $year";

    print OUT "Prepared: $prepdate. Service effective: $effdate." ;
#    print OUT "\r";

    close OUT;

}

sub get_head_timepoints {

   # returns the default timepoint *across* columns.

   my @points = @{+shift};
   my %tpfreq = ();
   my %tpcols = ();
   my %exact = ();

   local ($_);

   for ( my $column = ( $#points); 
            $column >= 0;  $column-- ) {

      $_ = $points[$column]{M_TPXREF};
      $tpfreq{$_}++;
      $tpcols{$_} = $column;
      $exact{$_}  = $points[$column]{M_EXACT};
   }


   my $thistp = (sort {
           $tpfreq{$b} <=> $tpfreq{$a} or
           $tpcols{$a} <=> $tpcols{$b}
           } keys %tpfreq)[0] ;

   # get the keys of %tpfreq (which are the timepoint abbrevations), 
   # sort them descending by value, and 
   # return the first (highest) one.  If two or more are the same, 
   # picks the first one in order by column.

   my $justoneheadtp = 0;
   $justoneheadtp = 1 if scalar(%tpfreq) == 1;

   return ($thistp, $exact{$thistp} , $justoneheadtp)

}

sub signdescription {

   my ($signid) = shift;

   my $uniqueid = $signs{$signid}{UNIQUEID};
   my $thisstop = $stops{$uniqueid}; # this is a reference

   my ($on, $at) = ($thisstop->{OnF} , $thisstop->{AtF} ) ;

   foreach ($on , $at) {

      s/Av\.?$/Ave./;
      s/Wy\.?$/Way/;
      s/Path\.$/Path/;
      s/Park\.$/Park/;
      s/Ln\.$/Lane/;
      s/Lp\.$/Loop/;

   }

   my $description = "";

   my $direction = $thisstop->{DirectionF}; 
   $direction = $Skedvars::longdirnames{$direction} 
        if $Skedvars::longdirnames{$direction};

   $description .= "$thisstop->{StNumF} " 
          if $thisstop->{StNumF};
   $description .= $thisstop->{OnF};
   $description .= " at $thisstop->{AtF}" 
          if $thisstop->{AtF};
   $description .= 
           ", " . $thisstop->{CityF} .
           ", going $direction (#$signid; stop $uniqueid)";
   
   return $description;

}

sub getcolor {

   local $_ = $_[0];

   our %lines;
   return $lines{$_}{Color} if $lines{$_}{Color};

   return "Local" if /^\d\d?$/;
   # return "Local" if it's one or two digits

   return "Transbay" if $_ ge "A";
   # return "Transbay" if it's a letter

   # That's nearly all of them, here are some exceptions

   return "EBExpress" if /\dX/;
   return "EBLimited" if /\dL/;

   my $firstchar = substr($_,0,1);

   if (/^\d\d\d/) {
      return "School" if $firstchar eq  "6";
      return "LocalLtdHours" if $firstchar eq  "3";
   }

   return "Local";

}
