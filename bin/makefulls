#!/usr/bin/perl
# 

# makefulls
#
# This program generates full schedules suitable for pouring into
# a desktop publishing program.

use strict;
use warnings;

use constant BIGSPACE => '<\q>' x 2;
use constant BOXBREAK => '<\\b>';

our %icons = 
    (
      ST => '<f"Zapf Dingbats">H<f$>',
      SD => '<f"Carta">V<f$>',
      SH => '<f"Festive"><\#105><f$>',
      '*' => '<f"Transportation"><\#121><f$>',
    );

# icons for printing. These are Quark codes.

# initialization

use FindBin('$Bin'); 
   # so $Bin is the location of the very file we're in now

use lib $Bin; 
   # there are few enough files that it makes sense to keep
   # main program and library in the same directory

# libraries dependent on $Bin

use Skedfile qw(Skedread remove_blank_columns);
use Skeddir;
use Skedvars;
use Byroutes 'byroutes';
use FPMerge qw(FPread FPread_simple);
use Skedtps qw(%tphash TPXREF_FULL); 
use Myopts;

my %options;
Myopts::options (\%options, Skeddir::options(), 'quiet!');
# command line options in %options;

$| = 1; # make stdout "hot"

print <<"EOF" unless $options{quiet};
makefulls - This is the makefulls program. It creates printable full
schedules for each schedule in the system.

EOF

my $signup;
$signup = (Skeddir::change (\%options))[2];
# Takes the necessary options to change directories, plus 'quiet', and
# then changes directories to the "Skeds" base directory.

Skedtps::initialize(TPXREF_FULL);

mkdir "fulls" or die "Can't create 'fulls' directory" unless -d 'fulls';

# open and load files

print "Using signup $signup\n\n" unless $options{quiet};

print <<"EOF" unless $options{quiet};
Now loading data...
EOF

# read in FileMaker Pro data into variables in package main

print "Timepoints and timepoint names... " unless $options{quiet};
my $vals = Skedtps::initialize;
print "$vals timepoints.\n" unless $options{quiet};

our (%lines , @lines);
FPread_simple("Lines.csv" , \@lines, \%lines , 'Line');

our (%fullnotes , @fullnotes);
FPread("FullNotes.csv" , \@fullnotes, \%fullnotes , 'SkedID');

open DATE , "<effectivedate.txt" 
      or die "Can't open effectivedate.txt for input";

our $effdate = scalar <DATE>;
close DATE;
chomp $effdate;

# main loop

print "Now processing full schedules.\n" unless $options{quiet};

my @files = glob ("skeds/*-a.txt");

foreach my $file (@files) {

    my %usedroutes = ();
   
    my $sked = Skedread ($file); 

    print STDOUT "\nProcessing " , $sked->{SKEDNAME} 
            unless $options{quiet};

    output_fullsched ($sked);

    $usedroutes{$_}++ foreach @{$sked->{ROUTES}};

    my @routes = sort byroutes keys %usedroutes;

    foreach my $i ( 1 .. ( 2**(scalar @routes)) - 2 ) {
        # this skips the all-bits-off subset (0)
        # and all-bits-on subset ( 2**(scalar @routes) - 1)
        my @subset = () ; # ref to empty list
        foreach my $j ( 0 .. $#routes) {
           push @subset, $routes[$j] 
              if $i & (2**$j);
                 # add the $j'th entry to the subset,
                 # if bit $j is on in $i
        }

        print " [" , join("+" , @subset) , "]";
        output_fullsched ($sked, \@subset);
    }

}

print "\n";

sub output_fullsched {

   my $givensked = shift;
   my $subset = shift; # optional

   my $sked = copy_sked($givensked); 
   # copy $givensked to $sked. We don't want to trim the times away
   # from the given sked, because we may make a next pass...

   my %routes = trim_sked($sked, $subset);
   # trim away unused rows, duplicate rows, and unused columns.
   # returns a hash, where the keys are the rows used in this subset
   # (could be all of them), and the values are true. This allows
   # $routes{"some_route"} to act as an is-an-element lookup.

   my $bottomnotes = whole_sked_notes ($sked, \%routes);
   # note definitions at the bottom of the page. These are the ones
   # associated with the schedule.

   # The following puts the note definitions in %notedefs.
   # I am currently ignoring the NOTES field, since the only thing in there
   # is the misleading bicycle information. Add code here to deal with it
   # if there are more notes later. This is still here because NOTEDEFS
   # includes definitions for SPECDAYS as well as for NOTES.
   my %notedefs = ();
   foreach (sort @{$sked->{NOTEDEFS}}) {
      my ($note, $def) = split (/:/);
      $notedefs{$note} = $def;
   }

   ### establish information about the days of service
   # $specdays is true if there is a special day note for any 
   # row (but not for ALL rows, just for one or a few rows).
   # The default days will be in $day (whether they are the
   # regular WE, WD, etc., or whether they are SD or SH or a 
   # pair of days like TT). $headday will be the longer text associated with
   # this code ("Monday through Friday", "Daily", etc.)

   my $specdays = 0;
   my $day = $sked->{DAY};
   my %specdays;

   if ( (exists $sked->{SPECDAYS}) and
        ( length(join ("" , @{$sked->{SPECDAYS}})) > 0 ) ) {
      # if there are any special days in the schedule
 
      $specdays{$_ or "BLANK"} = 1 foreach ( @{$sked->{SPECDAYS}} ) ;

      if ((scalar keys %specdays) == 1 ) { 
         # if there's only one special day
         $day = (keys %specdays)[0];
      } else {
         $specdays = 1;
         delete $specdays{BLANK};
      }
      # now %specdays includes all the special days
   }

   # establish the days used in the head
   my $headday;
   if ($notedefs{$day}) {
      $headday = $notedefs{$day};
      $headday =~ s/ only//i;
   } else {
      $headday = $Skedvars::longerdaynames{$day} || $day;
   }
  $headday .= BIGSPACE . $icons{ST} if $bottomnotes;
  # add the "star" icon to the headday if it's relevant
  
   # put special days in the notes

   if ($specdays) {
      foreach my $thisday (sort keys %specdays) {
         next if $thisday eq $day;
         $bottomnotes .= "\n" if $bottomnotes;
         $bottomnotes .= $icons{$thisday} . BIGSPACE . $notedefs{$thisday};
      }
   }

   my @routes = sort byroutes keys %routes;

   ### Create rest of head, besides headday

   # head numbers and names
   my $headnum = join (" / " , @routes);
   my @names = ();
   foreach (@routes) {
      push @names, $lines{$_}{Name} if $lines{$_}{Name};
   }
   my $headname = join (" / " , @names);

   # the following is to get the head destination,
   # which will be the last used timepoint
   my $headdest = $tphash{$sked->{TP}[-1]} || $sked->{TP}[-1];

   ### set up some flags and convenience variables

   my $notescol =  $specdays;
   # if we ever have other kinds of notes, this allows us to add them
   # by changing this statement

   my $routescol = (scalar (keys %routes) > 1);

   my $tpcolumns = (scalar @{$sked->{TP}} );
   my $rows = (scalar @{$sked->{ROUTES}} );

   my $extracolumns = ($notescol ? 1 : 0) + ($routescol ? 1 : 0) ;
   # number of columns beyond the ones needed for the timepoint

   ### open output file
   my $fullsdir = "fulls/" . $sked->{LINEGROUP};
   mkdir $fullsdir or die "Can't create directory $fullsdir"
       unless -d $fullsdir;
   my $outfile = $sked->{DAY} . "_" . $sked->{DIR};
   $outfile = join("_", @$subset) . "_$outfile" if $subset;
   $outfile .= "-$tpcolumns-f.txt";
   open OUT , ">$fullsdir/$outfile" or die "Can't open $outfile for writing";

   ### print head

   print OUT '@headnum:' , $headnum , BOXBREAK;
   print OUT '@headname:' , $headname , "\n";
   print OUT '@headdest:To ' , $headdest , "\n";
   print OUT '@headdays:' , $headday , BOXBREAK;

   ### print timepoint numbers in boxes
   # TODO - arrange to match the boxes to the line maps (probably
   # by having the user enter map info in FullNotes.fp5)
   # also, figure out if you should add blank entries to the boxes.
   # at this point, I don't know how many different timetable templates
   # there will be.

   print OUT join(BOXBREAK, (1 .. $tpcolumns) ) , BOXBREAK;
   
   print OUT '@tpname:' if ($notescol or $routescol);
   print OUT 'Route' if $routescol; 
   print OUT ' and ' if ($notescol and $routescol);
   print OUT 'Notes' if $notescol;
  
   # print the long timepoints
   
   for my $col ( 0 .. $tpcolumns - 1) {
      print OUT BOXBREAK , '@tpname:';
      unless ($col == 0) 
      { 
         print OUT "Dep. " if 
         ($sked->{TP}[$col-1] eq $sked->{TP}[$col]);
      }
      unless ($col == $tpcolumns - 1) 
      # unless this is the last column, check to see if the next one
      # is the same as this one
      {
         print OUT "Arr. " if 
           ($sked->{TP}[$col+1] eq $sked->{TP}[$col]);
      }
      my $thistp = $tphash{$sked->{TP}[$col]} || $sked->{TP}[$col];
      $thistp =~ s/ (Apts|Ave|Blvd|St|Ct|Dr|Rd|Pkwy|Sq|Terr|Fwy|Pl)\./<\\!s>$1./g;
      $thistp =~ s/ (Plaza|Lane|School|Way|Mall|Road)/<\\!s>$1/g;
      # make non-breaking spaces where we know we can
      print OUT $thistp;
   }

   ### print rows of times

   print OUT BOXBREAK; # to start the box

   for my $row (0 .. $rows - 1) {

      print OUT "\n" if $row; # all but the first one
      print OUT '@times:';
      print OUT ($sked->{ROUTES}[$row] ) if $routescol;

      # currently this just does specdays. If you add other notes,
      # make an array of the relevant notes and print them all
      
      print OUT ($sked->{SPECDAYS}[$row] ) if $notescol;

      print OUT "\t";

      print OUT ($sked->{ROUTES}[$row] ) if $routescol;

      for my $col (0 .. $tpcolumns - 1 ) {
         my $time = $sked->{TIMES}[$col][$row] || "";
         my $ampm = chop $time;
         substr($time, -2, 0) = ":" if $time;
         if ($ampm eq "p") {
            print OUT "\t" , '<f"HelveticaNeue BoldCond">' , $time, '<f$>';
         } else {
            print OUT "\t$time";
         } 
      }

      # add blank space for rules
      print OUT "\n\@timesblank:" unless (($row+1) % 6) ;
   } # row

   print OUT BOXBREAK , '@legend:Light Face = a.m.' , BIGSPACE;
   print OUT '<f"HelveticaNeue BoldCond">Bold Face = p.m.<f$>' ;
   print OUT "\n" , $bottomnotes;

   close OUT;

}

sub copy_sked {

   # takes a schedule and returns a reference to a copy of all the 
   # data in the schedule

   my ($givensked) = @_;

   my $sked = {}; # empty anonymous hash

   ### make a copy of all data in $givensked into $sked
   #   (we have to do this because otherwise we will screw up future
   #   passes with this data)

   # first, copy scalars
   $sked->{$_} = $givensked->{$_} foreach qw(SKEDNAME LINEGROUP DIR DAY);
   # then, copy arrays
   @{$sked->{$_}} = @{$givensked->{$_}} 
      foreach qw(SPECDAYS NOTES ROUTES NOTEDEFS TP);

   # then, copy TIMES (an array of arrays)
   $sked->{TIMES} = []; # ref to empty array

   foreach my $col (0 .. scalar (@{$givensked->{TP}}) - 1) {
      push @{$sked->{TIMES}} , [ @{$givensked->{TIMES}[$col]} ];
   }

   return $sked;

}

sub trim_sked {

   my ($sked, $subset) = shift;

   # the following will remove any rows that are for 
   # routes we don't want right now.  

   my %routes = ();

   my $totalrows = scalar (@{$sked->{ROUTES}});

   if ($subset) { # if any routes are given

      # provides an easy "is an element" lookup
      $routes{$_} = 1 foreach @$subset;

      my $count = 0;
      while ($count < $totalrows) {
         if ($routes{$sked->{ROUTES}[$count]}) {
            $count++;
         } else {
            $totalrows--;
            foreach ( qw(ROUTES NOTES SPECDAYS)) {
               splice ( @{$sked->{$_}} , $count, 1);
            }
            foreach my $col ( 0 .. ( (scalar @{$sked->{TP}}) - 1) ) {
                 splice ( @{$sked->{TIMES}[$col]} , $count, 1);
            }
         }
      }
   } else { # no routes are given, so use them all
      $routes{$_} = 1 foreach @{$sked->{ROUTES}};
   }

   ### merge identical rows

   my $row = 1;    # not the first one -- has to be the second so it can
                   # be compared to the first. Arrays start at 0.

   IDENTIROW:
   while ($row < $totalrows) {

      my $this = "";
      my $prev = "";

      foreach my $col (0 .. scalar @{$sked->{TP}} - 1) {
         my $thistime = $sked->{TIMES}[$row][$col];
         my $prevtime = $sked->{TIMES}[$row-1][$col];

         $this .= $thistime if defined $thistime;
         $prev .= $prevtime if defined $prevtime;
      }

      if ($this ne $prev) {
         $row++;
      } else {

         if (join ("", sort 
              ($sked->{SPECDAYS}[$row],
               $sked->{SPECDAYS}[$row-1],
                )) eq "SDSH") 
         {
            $sked->{SPECDAYS}[$row-1] = "",
         }

         # if the times are identical, and one is a school holiday and
         # the other is school days only, eliminate the special days 
         # on the remaining # timepoint.

         $totalrows--;
         foreach (qw(ROUTES NOTES SPEC DAYS)) {
            splice ( @{$sked->{$_}} , $row, 1);
         }
         foreach ( 0 .. ( (scalar @{$sked->{TP}}) - 1) ) {
              splice ( @{$sked->{TIMES}[$_]} , $row, 1);
         }
         # eliminate this row
      } # if $this ne $prev 

   } # identirow

   ### remove columns for timepoints that aren't used

   remove_blank_columns($sked);

   return %routes;

}

sub whole_sked_notes {

   ### Assemble text of notes at bottom of page.
   ### These are ones that apply to the whole sked -- not to particular rows

   my $sked = shift;

   unless (exists ($fullnotes{$sked->{SKEDNAME}})) {
      return "";
   } # if there aren't any full notes for this sked, skip it

   my %routes = %{+shift};
 
   my @wholenotes = ();
   my @notes2check;

   if (ref ($fullnotes{$sked->{SKEDNAME}}) eq "ARRAY") {
      @notes2check = @{$fullnotes{$sked->{SKEDNAME}}};
   } else { # it's a single one of the hash
      @notes2check = ( $fullnotes{$sked->{SKEDNAME}}) ;
   }

   FULLNOTE:
   foreach my $thisfullnote ( @notes2check ) {
      foreach my $thisnoteline (split (/\n/ , $thisfullnote->{Lines})) {
         if ($routes{$thisnoteline}) {
            push @wholenotes, $thisfullnote->{Note};
            next FULLNOTE;
         }
      }
   }

   # so now @wholenotes contains all the notes that apply to the whole page.
 
   my %wholenotes;
   foreach (@wholenotes) {
      $wholenotes{$_} = 1 if $_;
   }
   @wholenotes = sort keys %wholenotes; # so now @wholenotes is unique

   @wholenotes = () unless join("" , @wholenotes);
   # if the contents of @wholenotes is empty, zero the thing out

   my $bottomnotes;
   if (@wholenotes) {
      $bottomnotes = $icons{ST} . BIGSPACE . join(" " , @wholenotes);
   } else {
      $bottomnotes = "";
   }

   return $bottomnotes;

}

